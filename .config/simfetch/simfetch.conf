#!/bin/bash

# --- Color Scheme: Catppuccin Mocha ---
PINK='\033[38;2;245;194;231m'
MAUVE='\033[38;2;203;166;247m'
RED='\033[38;2;243;139;168m'
PEACH='\033[38;2;250;179;135m'
YELLOW='\033[38;2;249;226;175m'
GREEN='\033[38;2;166;227;161m'
TEAL='\033[38;2;148;226;213m'
SKY='\033[38;2;137;220;235m'
BLUE='\033[38;2;137;180;250m'
LAVENDER='\033[38;2;180;190;254m'
TEXT='\033[38;2;205;214;244m'
NC='\033[0m'
# ----------------------------------------

# --- USER CONFIGURATION ---
# Image Backend Choice:
# "auto"     -> Automatically detect: kitty -> ascii
# "kitty"    -> Kitty image protocol (HD, fastest)
# "ascii"    -> ASCII art using jp2a/img2txt
# "none"     -> Text only

IMAGE_BACKEND="auto"
IMAGE_PATH="/home/azunya/Pictures/azusa_k_on_by.png" # IMPORTANT: Change this to your image path
SPACING=5

# Image display settings
IMAGE_SIZE="auto"  # "auto", "small", "medium", "large", or "WxH" (e.g., "30x15")
IMAGE_QUALITY="low"  # "low", "medium", "high"
# ----------------------------

# --- ICON + LABEL (NERD FONTS) ---
SHOW_DISTRO="yes"
SHOW_KERNEL="yes"
SHOW_UPTIME="yes"
SHOW_DE="yes"
SHOW_WM="yes"
SHOW_CPU="yes"
SHOW_GPU="yes"
SHOW_SHELL="yes"
SHOW_PACKAGES="yes"
SHOW_MEMORY="yes"

LBL_DISTRO="${SKY}󰌖 Distro${NC}"
LBL_KERNEL="${PEACH}󰌢 Kernel${NC}"
LBL_UPTIME="${YELLOW}󰔟 Uptime${NC}"
LBL_DE="${PINK}󰍺 DE${NC}"
LBL_WM="${MAUVE}󰖲 WM${NC}"
LBL_CPU="${RED}󰻠 CPU${NC}"
LBL_GPU="${RED}󰍹 GPU${NC}"
LBL_SHELL="${TEAL} Shell${NC}"
LBL_PACKAGES="${GREEN}󰏖 Packages${NC}"
LBL_MEMORY="${GREEN}󰍛 Memory${NC}"
# -----------------------------------

# --- GLOBAL VARIABLES ---
declare -a info_lines=()
declare -a art_lines=()
art_width=0
art_height=0
color_icons=""
# ------------------------

# --- DETECTION FUNCTIONS ---
detect_terminal() {
    case "$TERM_PROGRAM" in
        "vscode") echo "vscode" ;;
        *) case "$TERM" in
            "xterm-kitty") echo "kitty" ;;
            "screen"*|"tmux"*) echo "multiplexer" ;;
            *) echo "generic" ;;
        esac ;;
    esac
}

get_terminal_size() {
    local cols lines
    cols=$(tput cols)
    lines=$(tput lines)
    
    # Attempt to get pixel dimensions
    local pixel_width pixel_height
    if [[ "$TERM" == "xterm-kitty" ]]; then
        # Kitty specific
        pixel_width=$((cols * 10))  # Approximate
        pixel_height=$((lines * 20))
    else
        # Generic calculation
        pixel_width=$((cols * 8))
        pixel_height=$((lines * 16))
    fi
    
    echo "${cols}x${lines}:${pixel_width}x${pixel_height}"
}

calculate_image_size() {
    local terminal_info=$(get_terminal_size)
    local term_cols=${terminal_info%%x*}
    local term_lines=${terminal_info#*x}; term_lines=${term_lines%%:*}
    
    case "$IMAGE_SIZE" in
        "small") echo "20x10" ;;
        "medium") echo "35x18" ;;
        "large") echo "50x25" ;;
        "auto")
            local max_width=$((term_cols / 3))
            local max_height=$((term_lines / 2))
            if ((max_width > 40)); then max_width=40; fi
            if ((max_height > 20)); then max_height=20; fi
            echo "${max_width}x${max_height}"
            ;;
        *x*) echo "$IMAGE_SIZE" ;;
        *) echo "30x15" ;;
    esac
}
# -------------------------

# --- SYSTEM INFO FUNCTIONS ---
get_info() {
    user_info="$USER@$(hostname)"
    
    # Distro info with better fallbacks
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        distro_info="$PRETTY_NAME"
    elif [ -f /etc/lsb-release ]; then
        . /etc/lsb-release
        distro_info="$DISTRIB_DESCRIPTION"
    elif command -v lsb_release >/dev/null 2>&1; then
        distro_info=$(lsb_release -d -s)
    else
        distro_info=$(uname -s)
    fi
    
    kernel_info=$(uname -r)
    uptime_info=$(uptime -p | sed 's/up //')
    
    # More accurate DE detection
    if [[ -n "$XDG_CURRENT_DESKTOP" ]]; then
        de_info="${XDG_CURRENT_DESKTOP##*:}"
        de_info="${de_info^}"
    elif [[ -n "$DESKTOP_SESSION" ]]; then
        de_info="${DESKTOP_SESSION^}"
    elif [[ -n "$KDE_FULL_SESSION" ]]; then
        de_info="KDE"
    elif [[ -n "$GNOME_DESKTOP_SESSION_ID" ]]; then
        de_info="GNOME"
    else
        de_info="Unknown"
    fi
    
    # More comprehensive WM detection
    wm_info=$(ps -e | grep -m 1 -o -E "mutter|KWin|kwin_x11|kwin_wayland|xfwm4|i3|
                                       i3-with-shmlog|bspwm|Hyprland|sway|openbox|
                                       fluxbox|qtile|marco|dwm|awesome|herbstluftwm|
                                       spectrwm|fvwm|jwm|icewm|enlightenment|windowmaker|
                                       afterstep|blackbox|pekwm|xmonad|cwm|2bwm|9wm|ratpoison|
                                       stumpwm|wmii|xpra|wingo|sowm|catwm|fvwm2|fvwm3|berry|dk|
                                       frankenwm|instantwm|katriawm|lwm|penrose|snapwm|tinywm|uwm|
                                       vtwm|wmx|yeahwm")
    
    if [[ -n "$wm_info" ]]; then
        wm_info="${wm_info^}"
    else
        case "$de_info" in
            "GNOME") wm_info="Mutter" ;;
            "KDE"*) wm_info="KWin" ;;
            "XFCE"|"Xfce") wm_info="Xfwm4" ;;
            "MATE") wm_info="Marco" ;;
            "Cinnamon") wm_info="Muffin" ;;
            "LXDE"|"LXQt") wm_info="Openbox" ;;
            *) wm_info="Unknown" ;;
        esac
    fi
    
    # CPU info with better cleanup
    cpu_info=$(awk -F: '/model name/{print $2; exit}' /proc/cpuinfo | sed 's/^[ \t]*//;s/[ \t]*$//')
    cpu_info=$(echo "$cpu_info" | sed 's/(R)//g;s/(TM)//g;s/CPU @ .*//;s/  */ /g')
    
    # GPU info - only the active/currently used GPU
    gpu_info=""
    
    # Method 1: Check GPU used for rendering
    if [[ -n "$DISPLAY" ]] && command -v glxinfo >/dev/null 2>&1; then
        # Get the GPU being used for OpenGL
        local active_gpu=$(glxinfo 2>/dev/null | grep -i "OpenGL renderer" | sed 's/.*: //' | head -n1)
        if [[ -n "$active_gpu" ]]; then
            gpu_info="$active_gpu"
        fi
    fi
    
    # Method 2: For Wayland or if glxinfo is unavailable
    if [[ -z "$gpu_info" ]] && [[ -n "$XDG_SESSION_TYPE" ]]; then
        if [[ "$XDG_SESSION_TYPE" == "wayland" ]] && command -v wlr-randr >/dev/null 2>&1; then
            # Try detection via Wayland compositor
            local wayland_gpu=$(wlr-randr 2>/dev/null | grep -i "connector\|output" | head -n1)
            if [[ -n "$wayland_gpu" ]]; then
                # Fallback to lspci for a better name
                gpu_info=$(lspci | grep -Ei 'VGA|3D|Display' | head -n1 | sed -e 's/^.*: //' -e 's/ (rev ..)//' -e 's/\[.*\]//')
            fi
        fi
    fi
    
    # Method 3: Check via /sys for an active GPU
    if [[ -z "$gpu_info" ]]; then
        # Look for a GPU with an active power state
        for gpu_path in /sys/class/drm/card*/device; do
            if [[ -r "$gpu_path/power_state" ]]; then
                local power_state=$(cat "$gpu_path/power_state" 2>/dev/null)
                if [[ "$power_state" == "D0" ]]; then
                    # GPU is in an active state
                    local pci_id=$(basename "$(readlink "$gpu_path")")
                    gpu_info=$(lspci -s "$pci_id" 2>/dev/null | grep -Ei 'VGA|3D|Display' | sed -e 's/^.*: //' -e 's/ (rev ..)//' -e 's/\[.*\]//')
                    if [[ -n "$gpu_info" ]]; then
                        break
                    fi
                fi
            fi
        done
    fi
    
    # Method 4: Check for active NVIDIA GPU via nvidia-smi
    if [[ -z "$gpu_info" ]] && command -v nvidia-smi >/dev/null 2>&1; then
        # Get the active NVIDIA GPU (with utilization > 0 or active processes)
        local nvidia_gpu=$(nvidia-smi --query-gpu=name,utilization.gpu --format=csv,noheader,nounits 2>/dev/null | awk -F', ' '$2 > 0 {print $1; exit}')
        if [[ -z "$nvidia_gpu" ]]; then
            # If no utilization, take the first one listed
            nvidia_gpu=$(nvidia-smi --query-gpu=name --format=csv,noheader,nounits 2>/dev/null | head -n1)
        fi
        if [[ -n "$nvidia_gpu" ]]; then
            gpu_info="$nvidia_gpu"
        fi
    fi
    
    # Method 5: Fallback to X11 session info
    if [[ -z "$gpu_info" ]] && [[ -n "$DISPLAY" ]] && command -v xrandr >/dev/null 2>&1; then
        # Check the active provider
        local active_provider=$(xrandr --listproviders 2>/dev/null | grep -v "Providers:" | head -n1 | sed 's/.*name://')
        if [[ -n "$active_provider" ]]; then
            # Map provider name to GPU hardware
            if echo "$active_provider" | grep -qi "intel"; then
                gpu_info=$(lspci | grep -i "intel.*graphics" | head -n1 | sed -e 's/^.*: //' -e 's/ (rev ..)//' -e 's/\[.*\]//')
            elif echo "$active_provider" | grep -qi "nvidia"; then
                gpu_info=$(lspci | grep -i "nvidia" | grep -Ei 'VGA|3D|Display' | head -n1 | sed -e 's/^.*: //' -e 's/ (rev ..)//' -e 's/\[.*\]//')
            elif echo "$active_provider" | grep -qi "amd\|radeon"; then
                gpu_info=$(lspci | grep -Ei 'AMD|ATI|Radeon' | grep -Ei 'VGA|3D|Display' | head -n1 | sed -e 's/^.*: //' -e 's/ (rev ..)//' -e 's/\[.*\]//')
            fi
        fi
    fi
    
    # Method 6: Final fallback - get primary GPU from lspci
    if [[ -z "$gpu_info" ]]; then
        gpu_info=$(lspci | grep -Ei 'VGA|3D|Display' | head -n1 | sed -e 's/^.*: //' -e 's/ (rev ..)//' -e 's/\[.*\]//')
    fi
    
    # Cleanup GPU name
    if [[ -n "$gpu_info" ]]; then
        gpu_info=$(echo "$gpu_info" | sed 's/Corporation //;s/Technologies //;s/Inc\. //;s/Ltd\. //;s/Co\. //;s/, Inc//;s/Advanced Micro Devices //;s/\[AMD\/ATI\] //;s/Intel Corporation //;s/Intel //;s/NVIDIA Corporation //;s/NVIDIA //;s/GeForce //')
    else
        gpu_info="Unknown"
    fi
    
    shell_info=$(basename "$SHELL")
    if [[ "$shell_info" == "bash" ]]; then
        shell_info="bash ${BASH_VERSION%%.*}"
    elif [[ "$shell_info" == "zsh" ]]; then
        shell_info="zsh $(zsh --version | cut -d' ' -f2)"
    fi
    
    # More accurate package count
    if command -v pacman >/dev/null 2>&1; then
        packages_info="$(pacman -Qq | wc -l) (pacman)"
    elif command -v dpkg-query >/dev/null 2>&1; then
        packages_info="$(dpkg-query -f '.\n' -W | wc -l) (apt)"
    elif command -v rpm >/dev/null 2>&1; then
        packages_info="$(rpm -qa | wc -l) (rpm)"
    elif command -v xbps-query >/dev/null 2>&1; then
        packages_info="$(xbps-query -l | wc -l) (xbps)"
    else
        packages_info="Unknown"
    fi
    
    # Memory with color
    memory_display=$(free -m | awk '/^Mem:/ {
        used = $3
        total = $2
        percentage = used * 100 / total
        color = ""
        if (percentage > 80) color = "\033[31m"      # Red
        else if (percentage > 60) color = "\033[33m" # Yellow
        else color = "\033[32m"                      # Green
        printf "%s%.1f / %.1f GB (%d%%)\033[0m", color, used/1024, total/1024, percentage
    }')
}
# -------------------------

# --- IMAGE DISPLAY BACKENDS ---
display_kitty_image() {
    local size=$(calculate_image_size)
    local width=${size%x*}
    local height=${size#*x}
    
    art_width=$width
    art_height=$height
    
    # Kitty image protocol with precise positioning
    # Display image
    kitty +kitten icat --align left --place "${width}x${height}@2x1" "$IMAGE_PATH" 2>/dev/null
    return 0
}

generate_ascii_art() {
    local size=$(calculate_image_size)
    local width=${size%x*}
    local height=${size#*x}
    
    local temp_ascii=$(mktemp)
    
    # Try jp2a first (better quality)
    if command -v jp2a >/dev/null 2>&1; then
        jp2a --width="$width" --height="$height" "$IMAGE_PATH" > "$temp_ascii" 2>/dev/null
    elif command -v img2txt >/dev/null 2>&1; then
        img2txt -W "$width" -H "$height" "$IMAGE_PATH" > "$temp_ascii" 2>/dev/null
    else
        return 1
    fi
    
    if [[ -s "$temp_ascii" ]]; then
        mapfile -t art_lines < "$temp_ascii"
        art_width=$width
        art_height=${#art_lines[@]}
        rm -f "$temp_ascii"
        return 0
    fi
    
    rm -f "$temp_ascii"
    return 1
}

generate_block_art() {
    local size=$(calculate_image_size)
    local width=${size%x*}
    local height=${size#*x}
    
    # Native bash implementation using Unicode blocks
    # This is a simplified version - would need ImageMagick or similar for full implementation
    if command -v magick >/dev/null 2>&1; then
        local temp_blocks=$(mktemp --suffix=.txt)
        
        # Convert to grayscale and resize
        magick "$IMAGE_PATH" -colorspace Gray -resize "${width}x${height}!" -depth 8 txt:- | \
        awk 'NR>1 {
            gsub(/[(),]/, " ", $3)
            intensity = int($4 * 255)
            if (intensity < 51) char = " "
            else if (intensity < 102) char = "░"
            else if (intensity < 153) char = "▒"
            else if (intensity < 204) char = "▓"
            else char = "█"
            printf "%s", char
            if (NR % '$width' == 1 && NR > 1) printf "\n"
        }' > "$temp_blocks"
        
        if [[ -s "$temp_blocks" ]]; then
            mapfile -t art_lines < "$temp_blocks"
            art_width=$width
            art_height=${#art_lines[@]}
            rm -f "$temp_blocks"
            return 0
        fi
        
        rm -f "$temp_blocks"
    fi
    
    return 1
}
# -------------------------

# --- DISPLAY FUNCTIONS ---
display_with_image() {
    local info_col=$((art_width + SPACING))
    local max_lines=$art_height
    
    if ((${#info_lines[@]} > max_lines)); then
        max_lines=${#info_lines[@]}
    fi
    
    # Display art and info side by side
    for ((i=0; i<max_lines; i++)); do
        # Display art line
        if ((i < art_height)) && [[ -n "${art_lines[i]}" ]]; then
            # Move cursor to position for art
            printf "\033[$((i + 1));2H"
            echo -ne "${art_lines[i]}"
        fi
        
        # Display info line
        if ((i < ${#info_lines[@]})) && [[ -n "${info_lines[i]}" ]]; then
            # Move cursor to position for info
            printf "\033[$((i + 1));${info_col}H"
            echo -e "${info_lines[i]}"
        fi
    done
    
    # Display color icons
    local color_icon_row=$((max_lines + 2))
    printf "\033[${color_icon_row};45H"
    echo -e "$color_icons"
    
    # Final cursor position
    local final_row=$((max_lines + 4))
    printf "\033[${final_row};0H"
}

display_text_only() {
    for ((i=0; i<${#info_lines[@]}; i++)); do
        printf "\033[$((i + 1));2H"
        echo -e "${info_lines[i]}"
    done
    
    local max_lines=${#info_lines[@]}
    local color_icon_row=$((max_lines + 2))
    printf "\033[${color_icon_row};2H"
    echo -e "$color_icons"

    local final_row=$((max_lines + 4))
    printf "\033[${final_row};0H"
}

prepare_info_lines() {
    local labels=() values=()
    
    # Collect enabled info
    if [[ "$SHOW_DISTRO" == "yes" ]]; then labels+=("$LBL_DISTRO"); values+=("$distro_info"); fi
    if [[ "$SHOW_KERNEL" == "yes" ]]; then labels+=("$LBL_KERNEL"); values+=("$kernel_info"); fi
    if [[ "$SHOW_UPTIME" == "yes" ]]; then labels+=("$LBL_UPTIME"); values+=("$uptime_info"); fi
    if [[ "$SHOW_DE" == "yes" ]]; then labels+=("$LBL_DE"); values+=("$de_info"); fi
    if [[ "$SHOW_WM" == "yes" ]]; then labels+=("$LBL_WM"); values+=("$wm_info"); fi
    if [[ "$SHOW_CPU" == "yes" ]]; then labels+=("$LBL_CPU"); values+=("$cpu_info"); fi
    if [[ "$SHOW_GPU" == "yes" ]]; then labels+=("$LBL_GPU"); values+=("$gpu_info"); fi
    if [[ "$SHOW_SHELL" == "yes" ]]; then labels+=("$LBL_SHELL"); values+=("$shell_info"); fi
    if [[ "$SHOW_PACKAGES" == "yes" ]]; then labels+=("$LBL_PACKAGES"); values+=("$packages_info"); fi
    if [[ "$SHOW_MEMORY" == "yes" ]]; then labels+=("$LBL_MEMORY"); values+=("$memory_display"); fi
    
    # Calculate max label length (ignoring ANSI codes)
    local max_label_len=0
    for label in "${labels[@]}"; do
        local len=$(echo -ne "$label" | sed 's/\x1b\[[0-9;?]*[mK]//g' | wc -m)
        if ((len > max_label_len)); then
            max_label_len=$len
        fi
    done
    
    # Format info lines
    info_lines=()
    for i in "${!labels[@]}"; do
        info_lines+=("$(printf "%-*b : ${TEXT}%s${NC}" "$max_label_len" "${labels[i]}" "${values[i]}")")
    done
    
    # Calculate max total length for the border
    local max_total_len=0
    for line in "${info_lines[@]}"; do
        local len=$(echo -ne "$line" | sed 's/\x1b\[[0-9;?]*[mK]//g' | wc -m)
        if ((len > max_total_len)); then
            max_total_len=$len
        fi
    done
    
    # Create bordered info box
    local title=" ${BLUE}󰣋 ${user_info}${NC} "
    local title_visible=$(echo -e "$title" | sed 's/\x1b\[[0-9;?]*[mK]//g')
    local title_len=${#title_visible}
    local bar_width=$((max_total_len + 2))
    local total_bar_len=$((bar_width - title_len))
    
    # Ensure lengths are non-negative
    [[ $total_bar_len -lt 0 ]] && total_bar_len=0
    local left_bar_len=$((total_bar_len / 2))
    local right_bar_len=$((total_bar_len - left_bar_len))
    
    local top_border="╭$(printf '─%.0s' $(seq 1 $left_bar_len))${title}$(printf '─%.0s' $(seq 1 $right_bar_len))╮"
    local bottom_border="╰$(printf '─%.0s' $(seq 1 $bar_width))╯"
    
    # Rebuild info_lines with borders
    local temp_info_lines=("${LAVENDER}${top_border}${NC}")
    for line in "${info_lines[@]}"; do
        local visible_line=$(echo -e "$line" | sed 's/\x1b\[[0-9;?]*[mK]//g')
        local current_len=${#visible_line}
        local padding=$((max_total_len - current_len))
        [[ $padding -lt 0 ]] && padding=0
        temp_info_lines+=("${LAVENDER}│${NC} ${line}$(printf '%*s' "$padding" '') ${LAVENDER}│${NC}")
    done
    temp_info_lines+=("${LAVENDER}${bottom_border}${NC}")
    
    info_lines=("${temp_info_lines[@]}")
}

display_info() {
    clear
    tput civis # Hide cursor
    
    # Setup cleanup trap
    trap 'tput cnorm; exit 0' EXIT INT TERM
    
    # Get system info
    get_info
    
    # Prepare formatted info lines
    prepare_info_lines
    
    # Prepare color icons
    color_icons="${RED}󰊠  ${GREEN}󰊠  ${YELLOW}󰊠  ${SKY}󰊠  ${PINK}󰊠  ${TEAL}󰊠  ${LAVENDER}󰊠 ${NC}"
    
    # Try to display image based on backend selection
    local image_displayed=false
    
    if [[ -f "$IMAGE_PATH" ]]; then
        case "$IMAGE_BACKEND" in
            "kitty")
                if [[ "$TERM" == "xterm-kitty" ]] && display_kitty_image; then
                    image_displayed=true
                fi
                ;;
            "ascii")
                if generate_ascii_art; then
                    display_with_image
                    image_displayed=true
                fi
                ;;
            "auto")
                # Auto-detection priority
                if [[ "$TERM" == "xterm-kitty" ]] && display_kitty_image; then
                    image_displayed=true
                elif generate_ascii_art; then
                    display_with_image
                    image_displayed=true
                fi
                ;;
        esac
    fi
    
    # Display based on whether the image was shown
    # ASCII/Block art calls its own display function, so we exclude it here.
    if [[ "$image_displayed" == true && "$IMAGE_BACKEND" != "ascii" && "$IMAGE_BACKEND" != "blocks" ]]; then
        # For protocols that draw async, we need to draw info after
        display_with_image
    elif [[ "$image_displayed" == false ]]; then
        # If no image was displayed at all
        display_text_only
    fi
    
    tput cnorm # Show cursor
}
# -------------------------

# --- MAIN EXECUTION ---
main() {
    # Check if image file exists
    if [[ ! -f "$IMAGE_PATH" ]]; then
        echo -e "${YELLOW}Warning:${TEXT} Image file not found at '$IMAGE_PATH'. Set the correct path in the script." >&2
        echo -e "${TEXT}Falling back to text-only mode.${NC}" >&2
        IMAGE_BACKEND="none"
        sleep 2
    fi
    
    # Run the display
    display_info
}

# Execute main function
main "$@"